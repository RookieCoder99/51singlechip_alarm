C51 COMPILER V9.54   KS0108                                                                03/18/2019 16:40:19 PAGE 1   


C51 COMPILER V9.54, COMPILATION OF MODULE KS0108
OBJECT MODULE PLACED IN .\output\KS0108.obj
COMPILER INVOKED BY: C:\Keil_v5\C51\BIN\C51.EXE KS0108.C LARGE OPTIMIZE(8,SPEED) BROWSE DEBUG OBJECTEXTEND PRINT(.\outpu
                    -t\KS0108.lst) TABS(2) OBJECT(.\output\KS0108.obj)

line level    source

   1          /*****************************************************************************
   2          * 文件名：KS0108.c
   3          * 说  明：操作KS0108系列芯片驱动液晶的基本函数
   4          *****************************************************************************/
   5          #include "main.h"
   6          
   7          #define DATA P0   //LCD12864数据线
   8          
   9          sbit RS = P2^7;   // 数据\指令 选择
  10          sbit RW = P2^6;   // 读\写 选择
  11          sbit EN = P2^5;   // 读\写使能
  12          sbit CS1 = P2^3;  // 片选1
  13          sbit CS2 = P2^4;  // 片选2
  14          
  15          /*************************************************************
  16          * 定义中文字库 
  17          *   宋体、小四（12），点阵为：宽x高=16x16，纵向取模、字节倒序
  18          **************************************************************/   
  19          uchar code PIC1616[]={
  20          //℃
  21          0x00,0x02,0x07,0xE7,0xFA,0x1C,0x06,0x02,0x02,0x02,0x02,0x02,0x06,0x1E,0x1E,0x00,
  22          0x00,0x00,0x00,0x07,0x1F,0x38,0x60,0x40,0x40,0x40,0x40,0x40,0x60,0x38,0x18,0x00,
  23          
  24          //当
  25          0x00,0x00,0x40,0x42,0x5E,0x5C,0x48,0x40,0x7F,0x7F,0x50,0x5E,0x4E,0xC4,0xC0,0x00,
  26          0x00,0x00,0x20,0x22,0x22,0x22,0x22,0x22,0x22,0x22,0x22,0x22,0x22,0x7F,0x7F,0x00, 
  27          //前
  28          0x08,0x08,0xE8,0xE8,0xA9,0xAF,0xEE,0xEA,0x08,0xC8,0xCC,0x0F,0xEB,0xEA,0x08,0x08,
  29          0x00,0x00,0x7F,0x7F,0x24,0x64,0x7F,0x3F,0x00,0x1F,0x5F,0xC0,0xFF,0x7F,0x00,0x00,
  30          
  31          //正
  32          0x00,0x02,0x02,0xC2,0xC2,0x02,0x02,0x02,0xFE,0xFE,0x82,0x82,0x82,0x82,0x82,0x02,
  33          0x20,0x20,0x20,0x3F,0x3F,0x20,0x20,0x20,0x3F,0x3F,0x20,0x20,0x20,0x20,0x20,0x20,
  34          //常
  35          0x20,0x38,0x18,0x09,0xEF,0xEE,0xAA,0xAF,0xAF,0xA8,0xEC,0xEF,0x2B,0x3A,0x18,0x08,
  36          0x00,0x00,0x3E,0x3E,0x02,0x02,0x02,0xFF,0xFF,0x02,0x12,0x32,0x3E,0x1E,0x00,0x00,
  37          
  38          //超
  39          0x40,0x48,0x48,0x48,0xFF,0xFF,0x48,0xCA,0xC2,0xFE,0xBE,0xA2,0xE2,0xFE,0xBE,0x00,
  40          0x60,0x7F,0x3F,0x60,0x7F,0x7F,0x42,0x42,0x5F,0x5F,0x48,0x48,0x48,0x5F,0x5F,0x40, 
  41          //温
  42          0x10,0x31,0xA7,0xF6,0x70,0x7E,0x7E,0x4A,0x4A,0x4A,0x4A,0x7E,0x7E,0x00,0x00,0x00,
  43          0x02,0xFE,0xFF,0x41,0x7F,0x7F,0x41,0x7F,0x7F,0x41,0x7F,0x7F,0x41,0x7F,0x7F,0x40,
  44          };
  45          
  46          /*************************************************************
  47          * 定义数字、符号点阵 
  48          *   宋体、小四（12），点阵为：宽x高=8x16；
  49          *   纵向取模、字节倒序（逆向、列行式）
  50          **************************************************************/
  51          uchar code PIC0816[]={
  52          0x00,0xE0,0xF0,0x18,0x08,0x18,0xF0,0xE0,0x00,0x0F,0x1F,0x30,0x20,0x30,0x1F,0x0F,//0
  53          0x00,0x10,0x10,0xF8,0xF8,0x00,0x00,0x00,0x00,0x20,0x20,0x3F,0x3F,0x20,0x20,0x00,//1
  54          0x00,0x70,0x78,0x08,0x08,0x88,0xF8,0x70,0x00,0x30,0x38,0x2C,0x26,0x23,0x31,0x30,//2
C51 COMPILER V9.54   KS0108                                                                03/18/2019 16:40:19 PAGE 2   

  55          0x00,0x30,0x38,0x88,0x88,0xC8,0x78,0x30,0x00,0x18,0x38,0x20,0x20,0x31,0x1F,0x0E,//3 
  56          0x00,0x00,0xC0,0xE0,0x30,0xF8,0xF8,0x00,0x00,0x07,0x07,0x24,0x24,0x3F,0x3F,0x24,//4
  57          0x00,0xF8,0xF8,0x88,0x88,0x88,0x08,0x08,0x00,0x19,0x39,0x21,0x20,0x31,0x1F,0x0E,//5
  58          0x00,0xE0,0xF0,0x98,0x88,0x98,0x18,0x00,0x00,0x0F,0x1F,0x31,0x20,0x31,0x1F,0x0E,//6
  59          0x00,0x38,0x38,0x08,0xC8,0xF8,0x38,0x08,0x00,0x00,0x00,0x3F,0x3F,0x00,0x00,0x00,//7 
  60          0x00,0x70,0xF8,0x88,0x08,0x88,0xF8,0x70,0x00,0x1C,0x3E,0x23,0x21,0x23,0x3E,0x1C,//8 
  61          0x00,0xE0,0xF0,0x18,0x08,0x18,0xF0,0xE0,0x00,0x00,0x31,0x33,0x22,0x33,0x1F,0x0F,//9 
  62          
  63          //up
  64          0x40,0x70,0x7C,0xFF,0xFF,0x7C,0x70,0x40,0x00,0x00,0x00,0x7F,0x7F,0x00,0x00,0x00,//10
  65          //down
  66          0x00,0x00,0x00,0xFE,0xFE,0x00,0x00,0x00,0x02,0x0E,0x3E,0xFF,0xFF,0x3E,0x0E,0x02,//11
  67          
  68          //-
  69          0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x01,0x01,0x01,0x01,0x01,0x01,0x01,//12
  70          //+
  71          0x00,0x00,0x00,0xF0,0xF0,0x00,0x00,0x00,0x01,0x01,0x01,0x1F,0x1F,0x01,0x01,0x01,//13
  72          
  73          //:
  74          0x00,0x00,0x00,0xC0,0xC0,0xC0,0x00,0x00,0x00,0x00,0x00,0x30,0x30,0x30,0x00,0x00,//14 
  75          //.
  76          0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x30,0x30,0x30,0x00,0x00,0x00,0x00,//15
  77          };
  78          
  79          /******************************************************
  80          * 函  数：检查LCD状态，是否忙
  81          * 参  数：空
  82          * 返回值：0空闲，非0忙
  83          ******************************************************/
  84          uchar check_state(void)   
  85          {
  86   1        uchar i = 0;
  87   1        uchar tmp = 0;    //状态信息（判断是否忙）
  88   1      
  89   1        RS = 0; //数据\指令选择，D/I（RS）=“L” ，表示 DB7∽DB0 为显示数据 
  90   1        RW = 1; //R/W=“H” ，E=“H”数据被读到DB7∽DB0 
  91   1        for(i=0; i<6; i++)
  92   1        {
  93   2          DATA = 0x00;
  94   2          EN = 1;   //EN下降源
  95   2          _nop_();  //一个时钟延时
  96   2          tmp = DATA;
  97   2          EN = 0;
  98   2          tmp = 0x80 & tmp; //仅当第7位为0时才可操作(判别busy信号)
  99   2          if(tmp == 0)
 100   2          {
 101   3            break;
 102   3          }
 103   2        }
 104   1        return(tmp);
 105   1      }
 106          
 107          /******************************************************
 108          * 函  数：写命令到LCD
 109          * 参  数：cmd要写的命令
 110          * 返回值：无
 111          ******************************************************/
 112          void write_cmd(uchar cmd)
 113          {
 114   1        uchar stat = 0;
 115   1        stat = check_state(); //状态检查，LCD是否忙
 116   1        RS = 0;   //向LCD发送命令。RS=0写指令，RS=1写数据
C51 COMPILER V9.54   KS0108                                                                03/18/2019 16:40:19 PAGE 3   

 117   1        RW = 0;   //R/W=“L” ，E=“H→L”数据被写到 IR 或 DR 
 118   1        DATA = cmd; //com :命令
 119   1        EN = 1;   //EN下降源
 120   1        _nop_();_nop_(); 
 121   1        EN = 0;
 122   1      }
 123          
 124          /******************************************************
 125          * 函  数：写数据到LCD
 126          * 参  数：dat要写的数据
 127          * 返回值：无
 128          ******************************************************/
 129          void write_data(uchar dat)  
 130          {
 131   1        uchar stat = 0;
 132   1        stat = check_state(); //状态检查，LCD是否忙
 133   1        EN = 0;   //先将EN管脚拉低
 134   1        _nop_();_nop_();
 135   1        RS = 1;   //RS=0写指令，RS=1写数据
 136   1        RW = 0;   //R/W="L" ，E="H→L"数据被写到 IR 或 DR 
 137   1        EN = 1;   //拉高EN管脚
 138   1        DATA = dat; //dat:显示数据
 139   1        _nop_();_nop_();
 140   1        EN = 0;   //数据在EN的下降沿被写入
 141   1      
 142   1      }  
 143          
 144          /******************************************************
 145          * 函  数：设置页地址：0xB8
 146          * 参  数：page页地址
 147          * 返回值：无
 148          ******************************************************/
 149          void set_page(uchar page) 
 150          {
 151   1        page = 0xB8|page; //1011 1xxx 0<=page<=7 设定页地址--X 0-7,8行为一页64/8=8，共8页
 152   1        write_cmd(page);
 153   1      }
 154          
 155          /******************************************************
 156          * 函  数：设定行地址--(X:0-63)：0xC0
 157          * 参  数：line行地址
 158          * 返回值：无
 159          ******************************************************/
 160          void set_line(uchar line)      
 161          {
 162   1        line = 0xC0|line; //1100 0000
 163   1        write_cmd(line);    //设置从哪行开始：0--63，一般从0 行开始显示
 164   1      }
 165          
 166          /******************************************************
 167          * 函  数：设定列地址--(Y:0-63)：0x40
 168          * 参  数：column列地址
 169          * 返回值：无
 170          ******************************************************/
 171          void set_column(uchar column) 
 172          {
 173   1        column = column&0x3f; //column最大值为64，越出 0=<column<=63
 174   1        column = 0x40|column; //01xx xxxx
 175   1        write_cmd(column);
 176   1      }
 177          
 178          /******************************************************
C51 COMPILER V9.54   KS0108                                                                03/18/2019 16:40:19 PAGE 4   

 179          * 函  数：开关显示：0x3E
 180          * 参  数：onoff开关，0x3E关显示，0x3F开显示
 181          * 返回值：无
 182          ******************************************************/
 183          void set_on(uchar onoff)     
 184          {
 185   1        onoff = 0x3E|onoff; //0011 111x,onoff只能为0或者1
 186   1        write_cmd(onoff);
 187   1      }
 188          
 189          /******************************************************
 190          * 函  数：选择屏幕
 191          * 参  数：screen: 0-全屏,1-左屏,2-右屏
 192          * 返回值：无
 193          ******************************************************/
 194          void select_screen(uchar screen)    
 195          {              
 196   1        switch(screen)
 197   1        { 
 198   2        case 0: 
 199   2          CS1=0;    //全屏
 200   2          _nop_(); _nop_(); _nop_(); 
 201   2          CS2=0; 
 202   2          _nop_(); _nop_(); _nop_(); 
 203   2          break; 
 204   2        case 1: 
 205   2          CS1=1;    //左屏
 206   2          _nop_(); _nop_(); _nop_(); 
 207   2          CS2=0;
 208   2          _nop_(); _nop_(); _nop_(); 
 209   2          break;
 210   2        case 2: 
 211   2          CS1=0;    //右屏
 212   2          _nop_(); _nop_(); _nop_(); 
 213   2          CS2=1;
 214   2          _nop_(); _nop_(); _nop_(); 
 215   2          break;
 216   2        }
 217   1      }
 218          
 219          /******************************************************
 220          * 函  数：清屏
 221          * 参  数：screen: 0-全屏,1-左屏,2-右屏
 222          * 返回值：无
 223          ******************************************************/
 224          void clear_screen(uchar screen)   
 225          {   
 226   1        uchar i,j;
 227   1      
 228   1        select_screen(screen); 
 229   1        for(i=0; i<8; i++)    //控制页数0-7，共8页
 230   1        {
 231   2          set_page(i);
 232   2          set_column(0);
 233   2          for(j=0; j<64; j++) //控制列数0-63，共64列
 234   2          {
 235   3            write_data(0x00); //写点内容，列地址自动加1
 236   3          }
 237   2        }        
 238   1      }
 239          
 240          /******************************************************
C51 COMPILER V9.54   KS0108                                                                03/18/2019 16:40:19 PAGE 5   

 241          * 函  数：初始化LCD
 242          * 参  数：空
 243          * 返回值：无
 244          ******************************************************/
 245          void ks0108_init(void)    
 246          { 
 247   1      
 248   1        check_state();
 249   1      
 250   1        select_screen(0);
 251   1        set_on(0);    //关显示
 252   1      
 253   1        select_screen(0);
 254   1        set_on(1);    //开显示
 255   1      
 256   1        select_screen(0);
 257   1        clear_screen(0);  //清屏
 258   1      
 259   1        set_line(0);    //开始行:0  
 260   1      }
 261          
 262          /******************************************************
 263          * 函  数：显示全角汉字（16x16图片）
 264          * 参  数：cs选屏参数，page选页参数，
 265          *         column选列参数，number图片序号（第几个汉字）
 266          * 返回值：无
 267          ******************************************************/
 268          void show_1616(uchar cs, uchar page, uchar column, uchar number)
 269          {
 270   1        int i;
 271   1          
 272   1        select_screen(cs);
 273   1        column = column&0x3f;
 274   1      
 275   1        set_page(page);     //写上半页
 276   1        set_column(column);   //控制列
 277   1        for(i=0; i<16; i++)   //控制16列的数据输出
 278   1        {
 279   2          write_data(PIC1616[i+32*number]); //i+32*number汉字的前16个数据输出   
 280   2        }
 281   1      
 282   1        set_page(page+1);   //写下半页
 283   1        set_column(column);   //控制列
 284   1          for(i=0;i<16;i++)   //控制16列的数据输出
 285   1        {
 286   2          write_data(PIC1616[i+32*number+16]);  //i+32*number+16汉字的后16个数据输出
 287   2        }
 288   1      
 289   1      } 
 290          
 291          /******************************************************
 292          * 函  数：显示半角汉字、数字、字母（08x16图片）
 293          * 参  数：cs选屏参数，page选页参数，
 294          *         column选列参数，number图片序号（第几个数字）
 295          * 返回值：无
 296          ******************************************************/
 297          void show_0816(uchar cs,uchar page, uchar column, uchar number)
 298          {
 299   1        uint i;
 300   1          
 301   1        select_screen(cs);
 302   1        column = column&0x3f;
C51 COMPILER V9.54   KS0108                                                                03/18/2019 16:40:19 PAGE 6   

 303   1      
 304   1        set_page(page);   //写上半页
 305   1        set_column(column);
 306   1          for(i=0;i<8;i++)
 307   1        {
 308   2          write_data(PIC0816[i+16*number]);
 309   2        }
 310   1        
 311   1        set_page(page+1); //写下半页
 312   1        set_column(column);
 313   1          for(i=0;i<8;i++)
 314   1        {
 315   2          write_data(PIC0816[i+16*number+8]);
 316   2        }
 317   1      }  
 318          
 319          /******************************************************
 320          * 函  数：显示当前时间
 321          * 参  数：str_time当前时间
 322          * 返回值：无
 323          ******************************************************/
 324          void show_time(SYSTEM_TIME str_time)
 325          {
 326   1        uchar tmp = 0;  
 327   1        show_0816(2, 0, 24, 2); //年  
 328   1        show_0816(2, 0, 32, 0);
 329   1        tmp = str_time.year/10;
 330   1        show_0816(2, 0, 40, tmp);
 331   1        tmp = str_time.year%10;
 332   1        show_0816(2, 0, 48, tmp);
 333   1        show_0816(2, 0, 56, 12);//-
 334   1      
 335   1        tmp = str_time.month/10;
 336   1        show_0816(1, 0, 0, tmp);//月
 337   1        tmp = str_time.month%10;
 338   1        show_0816(1, 0, 8, tmp);
 339   1        show_0816(1, 0, 16, 12);//-
 340   1      
 341   1        tmp = str_time.date/10;
 342   1        show_0816(1, 0, 24, tmp);//日
 343   1        tmp = str_time.date%10;
 344   1        show_0816(1, 0, 32, tmp);
 345   1        
 346   1        tmp = str_time.hour/10;
 347   1        show_0816(2, 2, 32, tmp);//时
 348   1        tmp = str_time.hour%10;
 349   1        show_0816(2, 2, 40, tmp);
 350   1        show_0816(2, 2, 48, 14);//:
 351   1      
 352   1        tmp = str_time.min/10;
 353   1        show_0816(2, 2, 56, tmp);//分
 354   1        tmp = str_time.min%10;
 355   1        show_0816(1, 2, 0, tmp);
 356   1        show_0816(1, 2, 8, 14);//:
 357   1      
 358   1        tmp = str_time.sec/10;
 359   1        show_0816(1, 2, 16, tmp);//秒
 360   1        tmp = str_time.sec%10;
 361   1        show_0816(1, 2, 24, tmp);
 362   1      }
 363          
 364          /******************************************************
C51 COMPILER V9.54   KS0108                                                                03/18/2019 16:40:19 PAGE 7   

 365          * 函  数：显示当前温度（含符号）
 366          * 参  数：up上限，down下限,state状态0正常，非0超温
 367          * 返回值：无
 368          ******************************************************/
 369          void show_temperature(uchar int_temper, uchar dec_temper, uchar state)
 370          {
 371   1        uchar tmp = 0;
 372   1        uchar symbol = 0;
 373   1        uchar int_tmp = 0;
 374   1        uint dec_tmp = 0;
 375   1      
 376   1        show_1616(2,4,0*16, 1);//当
 377   1        show_1616(2,4,1*16, 2);//前
 378   1      
 379   1        int_tmp = int_temper;
 380   1        if((int_tmp &0x80) != 0)
 381   1        {
 382   2          symbol = 1;       //符号为负
 383   2          int_tmp = ~int_tmp;
 384   2          dec_temper = (0x0F-dec_temper) +1;  //负数取反加1
 385   2          if(dec_temper == 0x10)      //小数部分进位，则整数进位
 386   2          {
 387   3            int_tmp += 1;
 388   3            dec_temper = 0;
 389   3          }
 390   2        }
 391   1      
 392   1        show_0816(2, 4, 32, 13-symbol); //+/-
 393   1        tmp = int_tmp/10;
 394   1        show_0816(2, 4, 40, tmp);
 395   1        tmp = int_tmp%10;
 396   1        show_0816(2, 4, 48, tmp);
 397   1        show_0816(2, 4, 56, 15);  //.
 398   1      
 399   1        dec_tmp = dec_temper;
 400   1        dec_tmp = dec_tmp * 625 + 500;  //对百分位进行四舍五入
 401   1        dec_temper = dec_tmp/1000;    //只显示十分位
 402   1      
 403   1        show_0816(1, 4, 0, dec_temper);
 404   1        show_1616(1, 4, 8, 0);
 405   1        
 406   1        //是否正常
 407   1        if(state == 0)
 408   1        {
 409   2          show_1616(1, 4, 32, 3);//正常
 410   2          show_1616(1, 4, 48, 4); 
 411   2        }else
 412   1        { 
 413   2          show_1616(1, 4, 32, 5);//超温
 414   2          show_1616(1, 4, 48, 6);//
 415   2        }
 416   1      }
 417          
 418          /******************************************************
 419          * 函  数：显示温度上、下限（含符号）
 420          * 参  数：up上限，down下限
 421          * 返回值：无
 422          ******************************************************/
 423          void show_area(uchar down, uchar up)
 424          {
 425   1        uchar tmp = 0; 
 426   1        uchar symbol = 0; 
C51 COMPILER V9.54   KS0108                                                                03/18/2019 16:40:19 PAGE 8   

 427   1        if((down&0x80) != 0)
 428   1        {
 429   2          down = 0xFF - down + 1;   //取反，加1
 430   2          symbol = 1;
 431   2        }
 432   1        show_0816(2, 6, 8+0, 11);   //下限显示
 433   1        show_0816(2, 6, 8+8, 13-symbol);  //+/-
 434   1        tmp = down/10;
 435   1        show_0816(2, 6, 8+16, tmp);
 436   1        tmp = down%10;
 437   1        show_0816(2, 6, 8+24, tmp);
 438   1        show_1616(2, 6, 8+32,0);      //℃  
 439   1        
 440   1        symbol = 0; 
 441   1        if((up&0x80) != 0)
 442   1        {
 443   2          up = 0xFF - up + 1;   //取反，加1
 444   2          symbol = 1;
 445   2        }
 446   1        show_0816(1, 6, 0, 10);   //上限显示
 447   1        show_0816(1, 6, 8, 13-symbol);    //+/-
 448   1        tmp = up/10;
 449   1        show_0816(1, 6, 16, tmp);
 450   1        tmp = up%10;
 451   1        show_0816(1, 6, 24, tmp);
 452   1        show_1616(1, 6, 32,0);    //℃     
 453   1      }


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =   1360    ----
   CONSTANT SIZE    =    480    ----
   XDATA SIZE       =   ----      27
   PDATA SIZE       =   ----    ----
   DATA SIZE        =   ----    ----
   IDATA SIZE       =   ----    ----
   BIT SIZE         =   ----    ----
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
